From 6f04601e4b73daa1d1922a8386917e50e7c77777 Mon Sep 17 00:00:00 2001
From: Jukka Rissanen <jukka.rissanen@linux.intel.com>
Date: Thu, 18 Oct 2012 17:21:58 +0300
Subject: [PATCH 1/3] service: We might know the passphrase for SSID already

We might know the passphrase for a new wifi service if we have
multiple wifi cards and we have successfully connected to known
wifi service at least once. So in this case try to connect to
AP using credentials from already known service.
---
 src/service.c | 116 +++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 111 insertions(+), 5 deletions(-)

diff --git a/src/service.c b/src/service.c
index 7381af3..c479143 100644
--- a/src/service.c
+++ b/src/service.c
@@ -122,6 +122,7 @@ struct connman_service {
 	connman_bool_t hidden_service;
 	char *config_file;
 	char *config_entry;
+	connman_bool_t ignore_connect_retry;
 };
 
 static connman_bool_t allow_property_changed(struct connman_service *service);
@@ -5176,22 +5177,49 @@ static int service_indicate_state(struct connman_service *service)
 int __connman_service_indicate_error(struct connman_service *service,
 					enum connman_service_error error)
 {
-	DBG("service %p error %d", service, error);
+	connman_bool_t new_connect_failed;
+
+	DBG("service %p error %d -> %d", service, service->error, error);
 
 	if (service == NULL)
 		return -EINVAL;
 
-	set_error(service, error);
+	new_connect_failed = error == CONNMAN_SERVICE_ERROR_CONNECT_FAILED &&
+			connman_service_get_favorite(service) == FALSE &&
+			__connman_service_get_passphrase(service) != NULL;
+
+	if (service->ignore_connect_retry == FALSE &&
+						new_connect_failed == TRUE) {
+		/*
+		 * We are here if the password we tried was not correct
+		 * one. So the next __connman_service_connect() will ask it
+		 * from the user.
+		 */
+		DBG("retrying connect...");
 
-	if (service->error == CONNMAN_SERVICE_ERROR_INVALID_KEY)
+		service->ignore_connect_retry = TRUE;
 		__connman_service_set_passphrase(service, NULL);
+		service->state = CONNMAN_SERVICE_STATE_IDLE;
+		service->error = CONNMAN_SERVICE_ERROR_INVALID_KEY;
+		service->userconnect = TRUE;
 
-	__connman_service_ipconfig_indicate_state(service,
+		__connman_service_connect(service);
+
+	} else {
+		set_error(service, error);
+
+		if (error == CONNMAN_SERVICE_ERROR_INVALID_KEY ||
+						new_connect_failed == TRUE)
+			__connman_service_set_passphrase(service, NULL);
+
+		__connman_service_ipconfig_indicate_state(service,
 						CONNMAN_SERVICE_STATE_FAILURE,
 						CONNMAN_IPCONFIG_TYPE_IPV4);
-	__connman_service_ipconfig_indicate_state(service,
+		__connman_service_ipconfig_indicate_state(service,
 						CONNMAN_SERVICE_STATE_FAILURE,
 						CONNMAN_IPCONFIG_TYPE_IPV6);
+	}
+
 	return 0;
 }
 
@@ -5538,6 +5566,75 @@ static void prepare_8021x(struct connman_service *service)
 							service->phase2);
 }
 
+static
+struct connman_service *check_if_already_known(struct connman_service *service)
+{
+	GSequenceIter *iter;
+	unsigned int service_len;
+	const unsigned char *service_ssid;
+
+	/*
+	 * The error is set to INVALID_KEY if we have tried the key already.
+	 */
+	DBG("ignore %d error %d", service->ignore_connect_retry,
+		service->error);
+
+	if (service->error == CONNMAN_SERVICE_ERROR_INVALID_KEY ||
+					service->ignore_connect_retry == TRUE)
+		return NULL;
+
+	service_ssid = connman_network_get_blob(service->network,
+						"WiFi.SSID", &service_len);
+
+	iter = g_sequence_get_begin_iter(service_list);
+
+	while (g_sequence_iter_is_end(iter) == FALSE) {
+		struct connman_service *other = g_sequence_get(iter);
+		unsigned int other_len;
+		const unsigned char *other_ssid;
+
+		if (other->type != CONNMAN_SERVICE_TYPE_WIFI ||
+				other->type != service->type ||
+				other->favorite != TRUE ||
+				other->ignore != FALSE ||
+				other->immutable != FALSE ||
+				(other->security !=
+					CONNMAN_SERVICE_SECURITY_WEP &&
+				other->security !=
+					CONNMAN_SERVICE_SECURITY_PSK) ||
+				other->security != service->security)
+			goto next;
+
+		other_ssid = connman_network_get_blob(other->network,
+						"WiFi.SSID", &other_len);
+
+		if (other_len == 0 || other_len != service_len)
+			goto next;
+
+		if (memcmp(other_ssid, service_ssid, service_len) == 0) {
+			DBG("found %p %s", other, other->identifier);
+			return other;
+		}
+
+	next:
+		iter = g_sequence_iter_next(iter);
+	}
+
+	return NULL;
+}
+
+static void use_passphrase(struct connman_service *service,
+						const char *passphrase)
+{
+	g_free(service->passphrase);
+	service->passphrase = g_strdup(passphrase);
+
+	if (service->network != NULL)
+		connman_network_set_string(service->network,
+					"WiFi.Passphrase",
+					service->passphrase);
+}
+
 static int service_connect(struct connman_service *service)
 {
 	int err;
@@ -5567,9 +5664,18 @@ static int service_connect(struct connman_service *service)
 		case CONNMAN_SERVICE_SECURITY_WPA:
 		case CONNMAN_SERVICE_SECURITY_RSN:
 			if (service->passphrase == NULL) {
+				struct connman_service *other;
+
 				if (service->network == NULL)
 					return -EOPNOTSUPP;
 
+				other = check_if_already_known(service);
+				if (other != NULL) {
+					use_passphrase(service,
+						other->passphrase);
+					break;
+				}
+
 				if (service->wps == FALSE ||
 					connman_network_get_bool(
 							service->network,
-- 
1.7.11.4

